## 核心价值

* 技术栈无关
  * 主框架不限制接入的技术栈，微应用具备完全自主权
* 独立开发、独立部署
* 增量升级
  * 面对复杂的系统，很难对已经存在的系统做全量的技术栈升级和技术重构
* 独立运行时
  * 每个微应用之间状态隔离，运行时状态不共享

## 出现背景

微前端架构旨在解决 单体应用在一个相对长的时间跨度下，由于参与的人员，团队的增多，变迁，从一个普通应用 变成一个 巨石 应用后，随之带来的不可维护的问题

## qiankun

* 简单，只需要简单地调用几个 API，即可完成应用的微前端改造
* 解耦/技术栈无关
  * 微前端的核心目标是将巨石应用拆解成若干个可以自治的松耦合应用

为此，做了以下努力：

* HTML entry
* 沙箱
* 应用间通信

**HTML entry**

另一个微前端框架 single-spa 采用的是 JS entry，即通过切换 JS 资源的地址来切换不同的子应用，这就意味着我们子应用必须打包在一个 JS 文件中，那么一些优化策略：**按需加载**、首屏优化、css 独立打包就没法使用了

HTML 就是读取 HTML 的资源，将返回的HTML字符串拆分为几部分 template、scripts、entry、styles（加载），将 template 通过DOM操作添加到主应用中，然后利用 eval 函数，执行 JS 代码，用 Promise.all 并行执行，最后执行 entry 脚本

**沙箱**

snapshotSandbox 快照沙箱，当激活沙箱的时候，把上下文，也就是 window 对象，存到 windowSnapshot 当中，当退出沙箱的时候，再从 windowSnapshot 中还原。但实际上为了保存沙箱的状态，当退出沙箱的时候，需要对 window 和windowSnapshot 做一个 diff，把结果保存在一个变量当中，当重新进入沙箱的时候，把这个状态给还原

缺点：只适合单个子应用

proxySandbox 代理沙箱，原理和上面类似，但是使用了 es6 的 proxy 实现，我们对上面方法的观察，发现只适合单个（有限个）子应用局限性在于显示地储存 window 的快照，在切换的时候，需要显示地去切换对于上下文状态，然后在 set 和 get 中对状态进行判定，代理到对应的对象当中，就可以支持多个子应用

**应用间通信**

原理和发布订阅模式差不多，当执行 render 方法挂载子应用的时候，将主应用的 action 实例注入，然后子应用可以获取和修改变量信息。变量是子应用之间全局共享的，当设置变量的值，会进行检查值的改变，通知到对应的观察者

## 为什么不是 iframe

抛开体验来说，iframe 是最完美的微前端解决方案了，iframe 的最大特性就是提供了浏览器原生的隔离方案，无论是 样式隔离，JS 隔离这类问题都被通通解决了。但它最大的问题也在于隔离无法被突破，导致上下文难以共享，随之带来的开发体验、产品体验的问题

* URL不同步，前进后退按钮无法使用
* UI 不同步，弹窗问题
* 全局上下文完全隔离，内存变量不共享
* 慢，每次一进入子应用都是浏览器上下文重建、资源加载的过程
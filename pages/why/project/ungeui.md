# UngeUI

## 目的与优势

最开始写这个组件库的时候，是为了学习前端组件封装的思想，说一说我的理解吧

## 为什么需要组件封装？

第一个是为了进行组件复用，譬如设计一个按钮，可能需要考虑按钮的宽度，高度，圆角，阴影，交互效果。而一个系统中，是会含有很多按钮的，这时候我们就可以封装一个按钮，

而又因为按钮的描述文字是各不相同的，所以允许外部传入文字描述作为属性，然后在组件中使用这个属性，看起来已经不错了。

理想总是很好，还有其他情况需要考虑，按钮也可能有多种风格。我们可以进行抽象，success danger warning info。抽象成几个可枚举的选项。看起来也已经不错了。

理想总是很好，现在又有其他需求，我们需要在按钮文字旁边添加 ICON，这个时候，我们难以枚举 ICON 的可能，因此，我们需要为组件设计插槽，使它更加灵活

* 属性
* 插槽

组件封装的另一种好处，状态分离或者说状态模块化。这里有一个问题就是，如果明确组件当前只会被使用一次，还有必要进行封装吗？

答案是有必要的，进行组件的封装，可以把组件有关的状态封装在组件内部，而不是暴露在外面，使得外部组件庞大而难以维护

类比 JS 模块化来说，我们不希望某些变量暴露在全局作用域下，防止作用域的不清晰的心智负担与数据意外的修改

## 亮点

基于自己的想法实现了两个一般组件库没有的组件

loadingBar 和 Transit

loadingBar 是页面加载时候顶部出现的进度条， 它的使用场景比如从一个页面跳转另一个页面，通常是需要一定的加载时间，需要一个组件来展示加载效果

使用方法就是，从包中导出 loadingBar 对象，在跳转前调用start方法，顶部出现加载条，结束后调用 end 方法

这里会有几个问题：

* 如何确保页面卸载的时候，loadingBar 不会消失，以及在目的页面加载完成如何让其消失？
  * 单例模式，利用 ESM 的模块特性，当导入一次的时候模块会被缓存下来，所以导入使用的是同一个对象实例
* 在动画实现方面。如果用 setInterval 会遇到问题，页面跳转时候通常来说可能会比较长，如果用户切换了 Tab 或者最小化，会导致 setInterval 计时不准确
  * requestAnimationFrame，不会有突然跳转的情况发生
* 在加载完成隐藏loadingBar的策略上，观察到其他人的实现，比如手机浏览器，他们在页面加载完成的一瞬间是直接让其消失的，非常突然
  * 我的解决策略就是说，因为用户可能在 loadingBar 的任意一个进度点，页面加载完成，可能是 30% ，50%，90%等等，我的解决策略就是固定让其在 300ms 内走完剩下的路程，达到一致性的丝滑体验

Transit

* 想法来源于 Gsap，但是打包后体积极大，不能接受，于是自己写了一个。

原理：

用我的组件包裹目标数字，当数字变化的时候，首先，用最后的值减去初始值，得到差值，例如从0 -> 1000，差值就是1000，用 1000 / duration，得到每 ms 走的步伐，希望每毫秒走 1个单位，当然一般做不到这么精确。用户看到的效果是取决于浏览器刷新率的，一般来说是60hz，即最小步幅也只能是 16.6ms。为了适配不同浏览器，依然采用了 requestAnimationFrame。如何做到适配不同刷新率的的呢？第一次运行记录下时间戳 temp，之后每次运行减去 temp 得到时间戳，